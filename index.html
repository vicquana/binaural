<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OOBE Binaural Beat Generator</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #1a1a2e; /* Deep space color */
        color: #e4e4e7;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 1rem;
      }
      .container {
        max-width: 500px;
        width: 100%;
        background-color: #272742;
        padding: 2rem;
        border-radius: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .control-button {
        transition: all 0.2s;
        box-shadow: 0 4px #0f0f18;
        transform: translateY(-2px);
      }
      .control-button:active {
        box-shadow: none;
        transform: translateY(0);
      }
      /* Custom radio button styling for channel preference */
      .radio-label {
        display: block;
        padding: 0.75rem 0.5rem;
        background-color: #3b3b64;
        border-radius: 0.75rem;
        cursor: pointer;
        text-align: center;
        transition: background-color 0.2s, box-shadow 0.2s;
        font-size: 0.9rem;
      }
      input[type="radio"]:checked + .radio-label {
        background-color: #6d28d9; /* Purple accent */
        box-shadow: 0 0 10px rgba(109, 40, 217, 0.7);
        font-weight: 600;
      }
      /* Slider styling */
      input[type="range"] {
        width: 100%;
        height: 8px;
        background: #3b3b64;
        border-radius: 5px;
        -webkit-appearance: none;
        margin: 10px 0;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #8b5cf6; /* Indigo/Purple thumb */
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      }
      input[type="range"]::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 50%;
        background: #8b5cf6;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      }

      .visual-indicator {
        width: 120px;
        height: 120px;
        border-radius: 9999px;
        margin: 0 auto;
        background: radial-gradient(circle at 30% 30%, #a78bfa, #4c1d95);
        opacity: 0.4;
        transition: opacity 0.05s ease, transform 0.05s ease,
          box-shadow 0.05s ease;
        box-shadow: 0 0 15px rgba(139, 92, 246, 0.35);
      }

      .visual-indicator.flash-on {
        opacity: 1;
        transform: scale(1.05);
        box-shadow: 0 0 35px rgba(196, 181, 253, 0.8),
          0 0 70px rgba(99, 102, 241, 0.7);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="text-3xl font-extrabold text-center mb-4 text-indigo-300">
        Brainwave Entrainment Frequencies
      </h1>
      <strong>Headphones Required.</strong> Use the sliders to set the
      <strong>Beat Frequency</strong> (difference) and the
      <strong>Carrier Frequency</strong> (base tone).

      <!-- Beat Frequency Slider -->
      <h2 class="text-xl font-semibold mb-3 text-indigo-400">
        1. Adjust Beat Frequency (Difference)
      </h2>
      <div class="flex justify-between text-sm text-gray-400 mb-1">
        <span id="beatMinLabel"></span>
        <span id="beatValue" class="font-bold text-lg text-white"></span>
        <span id="beatMaxLabel"></span>
      </div>
      <input
        type="range"
        id="beatSlider"
        min="1"
        max="15"
        value="4"
        step="0.1"
        class="mb-8"
      />

      <!-- Channel Preference (Defines which ear gets the higher frequency) -->
      <h2 class="text-xl font-semibold mb-3 text-indigo-400">
        2. Higher Frequency Ear
      </h2>
      <div class="flex justify-center mb-8">
        <button
          id="channelToggle"
          class="control-button bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-3 px-6 rounded-xl w-full"
        >
          Left Ear Higher
        </button>
      </div>

      <!-- Carrier Frequency Slider -->
      <h2 class="text-xl font-semibold mb-3 text-indigo-400">
        3. Adjust Carrier Frequency (Base Hz)
      </h2>
      <div class="flex justify-between text-sm text-gray-400 mb-1">
        <span id="carrierMinLabel"></span>
        <span id="carrierValue" class="font-bold text-lg text-white"></span>
        <span id="carrierMaxLabel"></span>
      </div>
      <input
        type="range"
        id="carrierSlider"
        min="100"
        max="500"
        value="232"
        step="1"
        class="mb-8"
      />

      <!-- Waveform Selection -->
      <h2 class="text-xl font-semibold mb-3 text-indigo-400">
        4. Waveform / Noise Type
      </h2>
      <select
        id="waveformSelect"
        class="w-full bg-[#3b3b64] text-white p-3 rounded-xl mb-8 focus:outline-none focus:ring-2 focus:ring-indigo-400"
      >
        <option value="sine">Sine (classic binaural)</option>
        <option value="triangle">Triangle</option>
        <option value="square">Square</option>
        <option value="isochronic">Isochronic Pulses</option>
        <option value="pink-noise">Pink Noise</option>
        <option value="brown-noise">Brown Noise</option>
        <option value="green-noise">Green Noise</option>
      </select>

      <!-- Controls -->
      <div class="flex flex-col items-center space-y-4">
        <button
          id="toggleToneButton"
          class="control-button text-white font-bold py-3 px-8 rounded-xl w-full text-lg"
        >
          Start Tone
        </button>
      </div>

      <p id="status" class="text-center mt-6 text-yellow-300 font-medium">
        Status: Initializing...
      </p>

      <div class="mt-8">
        <h2 class="text-xl font-semibold mb-3 text-indigo-400 text-center">
          Visual Beat Indicator
        </h2>
        <div id="visualIndicator" class="visual-indicator" aria-hidden="true"></div>
        <p class="text-center mt-2 text-sm text-gray-400">
          Flashes at the selected beat frequency.
        </p>
      </div>
    </div>

    <script>
      let isPlaying = false;
      let oscL, oscR;
      let pannerL, pannerR;
      let isoGainL, isoGainR, isoLfo;
      let noiseGainL, noiseGainR;
      let noiseFilterL, noiseFilterR;
      let channelPreference = "left";
      const statusElement = document.getElementById("status");
      const beatSlider = document.getElementById("beatSlider");
      const beatValueDisplay = document.getElementById("beatValue");
      const beatMinLabel = document.getElementById("beatMinLabel");
      const beatMaxLabel = document.getElementById("beatMaxLabel");
      const carrierSlider = document.getElementById("carrierSlider");
      const carrierValueDisplay = document.getElementById("carrierValue");
      const carrierMinLabel = document.getElementById("carrierMinLabel");
      const carrierMaxLabel = document.getElementById("carrierMaxLabel");
      const channelToggleButton = document.getElementById("channelToggle");
      const toggleToneButton = document.getElementById("toggleToneButton");
      const waveformSelect = document.getElementById("waveformSelect");
      const visualIndicator = document.getElementById("visualIndicator");

      const waveformLabels = {
        sine: "Sine",
        triangle: "Triangle",
        square: "Square",
        isochronic: "Isochronic Pulses",
        "pink-noise": "Pink Noise",
        "brown-noise": "Brown Noise",
        "green-noise": "Green Noise",
      };

      let flashIntervalId = null;
      let flashTimeoutId = null;

      function updateBeatLabels() {
        if (beatMinLabel) {
          beatMinLabel.textContent = `${beatSlider.min} Hz`;
        }
        if (beatMaxLabel) {
          beatMaxLabel.textContent = `${beatSlider.max} Hz`;
        }
        beatValueDisplay.textContent = `${parseFloat(beatSlider.value).toFixed(1)} Hz`;
      }

      function updateCarrierLabels() {
        if (carrierMinLabel) {
          carrierMinLabel.textContent = `${carrierSlider.min} Hz`;
        }
        if (carrierMaxLabel) {
          carrierMaxLabel.textContent = `${carrierSlider.max} Hz`;
        }
        carrierValueDisplay.textContent = `${carrierSlider.value} Hz`;
      }

      // Helper function to get the current carrier, beat, and channel preference
      function getCurrentFrequencies() {
        const carrier = parseFloat(carrierSlider.value);
        const beat = parseFloat(beatSlider.value);
        const waveform = waveformSelect.value;
        const waveformLabel = waveformLabels[waveform] || waveform;
        const modeName = `${waveformLabel} | ${beat.toFixed(1)} Hz Beat`;

        const channelLabel =
          channelPreference === "left" ? "Left Higher" : "Right Higher";

        return { carrier, beat, modeName, channelLabel, waveform, waveformLabel };
      }

      function isNoiseWaveform(waveform) {
        return ["pink-noise", "brown-noise", "green-noise"].includes(
          waveform
        );
      }

      function isIsochronicWaveform(waveform) {
        return waveform === "isochronic";
      }
      function updateToneButton() {
        toggleToneButton.classList.remove(
          "bg-red-500",
          "hover:bg-red-600",
          "bg-green-500",
          "hover:bg-green-600"
        );

        if (isPlaying) {
          toggleToneButton.textContent = "Stop Tone";
          toggleToneButton.classList.add("bg-red-500", "hover:bg-red-600");
        } else {
          toggleToneButton.textContent = "Start Tone";
          toggleToneButton.classList.add("bg-green-500", "hover:bg-green-600");
        }
      }

      function updateChannelToggle() {
        if (channelPreference === "left") {
          channelToggleButton.textContent = "Left Ear Higher";
          channelToggleButton.classList.remove(
            "bg-purple-500",
            "hover:bg-purple-600"
          );
          channelToggleButton.classList.add(
            "bg-indigo-500",
            "hover:bg-indigo-600"
          );
        } else {
          channelToggleButton.textContent = "Right Ear Higher";
          channelToggleButton.classList.remove(
            "bg-indigo-500",
            "hover:bg-indigo-600"
          );
          channelToggleButton.classList.add(
            "bg-purple-500",
            "hover:bg-purple-600"
          );
        }
      }

      // Function to update the status display
      function updateStatus(state) {
        const { carrier, beat, modeName, channelLabel, waveform, waveformLabel } =
          getCurrentFrequencies();

        // Determine which ear is higher for status display
        const isRightHigher = channelPreference === "right";
        const freqL = isRightHigher ? carrier : carrier + beat;
        const freqR = isRightHigher ? carrier + beat : carrier;

        const earStatus = `Left ${freqL.toFixed(1)} Hz / Right ${freqR.toFixed(
          1
        )} Hz`;

        const baseStatus = isNoiseWaveform(waveform)
          ? `${waveformLabel} (stereo)`
          : earStatus;

        if (state === "playing") {
          if (isIsochronicWaveform(waveform)) {
            statusElement.textContent =
              `Status: Playing Isochronic pulses at ${beat.toFixed(
                1
              )} Hz. Carrier ${carrier} Hz.`;
          } else if (isNoiseWaveform(waveform)) {
            statusElement.textContent = `Status: Playing ${baseStatus}.`;
          } else {
            statusElement.textContent = `Status: Playing ${modeName}. ${baseStatus}`;
          }
        } else {
          statusElement.textContent = `Status: Stopped. ${modeName}. Carrier ${carrier} Hz. (${channelLabel})`;
        }
        carrierValueDisplay.textContent = `${carrier} Hz`;
      }

      // Initialize Tone.js components
      function setupTone() {
        if (!Tone.context.state || Tone.context.state === "closed") {
          Tone.context.resume();
        }

        // 1. Create Stereo Pannners (to ensure left goes fully left and right fully right)
        pannerL = new Tone.Panner(-1).toDestination(); // Left channel
        pannerR = new Tone.Panner(1).toDestination(); // Right channel

        // 2. Create source placeholders; actual sources set per waveform
      }

      function disposeSources() {
        const disposables = [
          oscL,
          oscR,
          isoGainL,
          isoGainR,
          isoLfo,
          noiseGainL,
          noiseGainR,
          noiseFilterL,
          noiseFilterR,
        ];

        disposables.forEach((node) => {
          if (node) {
            if (typeof node.stop === "function") {
              try {
                node.stop();
              } catch (e) {
                // ignore stop errors for already-stopped nodes
              }
            }
            node.dispose();
          }
        });

        oscL = null;
        oscR = null;
        isoGainL = null;
        isoGainR = null;
        isoLfo = null;
        noiseGainL = null;
        noiseGainR = null;
        noiseFilterL = null;
        noiseFilterR = null;
      }

      function createWaveformSources() {
        const { waveform, carrier, beat } = getCurrentFrequencies();

        disposeSources();

        if (isNoiseWaveform(waveform)) {
          const noiseType =
            waveform === "pink-noise"
              ? "pink"
              : waveform === "brown-noise"
              ? "brown"
              : "white";

          const noiseSource = new Tone.Noise(noiseType);
          noiseGainL = new Tone.Gain(0.5).connect(pannerL);
          noiseGainR = new Tone.Gain(0.5).connect(pannerR);

          if (waveform === "green-noise") {
            // Green noise approximated via a band-pass filter in the mid frequencies
            noiseFilterL = new Tone.Filter({
              type: "bandpass",
              frequency: 500,
              Q: 1,
            }).connect(noiseGainL);

            noiseFilterR = new Tone.Filter({
              type: "bandpass",
              frequency: 500,
              Q: 1,
            }).connect(noiseGainR);

            noiseSource.connect(noiseFilterL);
            noiseSource.connect(noiseFilterR);
          } else {
            noiseSource.connect(noiseGainL);
            noiseSource.connect(noiseGainR);
          }

          oscL = noiseSource;
          oscR = noiseSource;
        } else if (isIsochronicWaveform(waveform)) {
          const baseOsc = new Tone.Oscillator(carrier, "sine");
          isoGainL = new Tone.Gain(0).connect(pannerL);
          isoGainR = new Tone.Gain(0).connect(pannerR);
          isoLfo = new Tone.LFO({
            type: "square",
            frequency: beat,
            min: 0,
            max: 1,
          });

          baseOsc.connect(isoGainL);
          baseOsc.connect(isoGainR);
          isoLfo.connect(isoGainL.gain);
          isoLfo.connect(isoGainR.gain);

          oscL = baseOsc;
          oscR = baseOsc;
        } else {
          oscL = new Tone.Oscillator(carrier, waveform).connect(pannerL);
          oscR = new Tone.Oscillator(carrier, waveform).connect(pannerR);
        }
      }

      // Function to calculate and set the frequencies based on the current selection
      function setFrequencies() {
        const { carrier, beat, waveform } = getCurrentFrequencies();

        if (isNoiseWaveform(waveform)) {
          updateStatus(isPlaying ? "playing" : "stopped");
          return;
        }

        if (isIsochronicWaveform(waveform)) {
          if (oscL) {
            oscL.frequency.setValueAtTime(carrier, Tone.context.currentTime);
          }
          if (isoLfo) {
            isoLfo.frequency.setValueAtTime(beat, Tone.context.currentTime);
          }
          updateStatus("playing");
          return;
        }

        let freqL = carrier;
        let freqR = carrier;

        // Apply the beat frequency based on the channel preference
        if (channelPreference === "right") {
          freqR = carrier + beat;
        } else {
          // Default to Left Higher
          freqL = carrier + beat;
        }

        if (oscL && oscR) {
          oscL.frequency.setValueAtTime(freqL, Tone.context.currentTime);
          oscR.frequency.setValueAtTime(freqR, Tone.context.currentTime);
        }
        updateStatus("playing");
      }

      function stopVisualFlashes() {
        if (flashIntervalId) {
          clearInterval(flashIntervalId);
          flashIntervalId = null;
        }
        if (flashTimeoutId) {
          clearTimeout(flashTimeoutId);
          flashTimeoutId = null;
        }
        visualIndicator.classList.remove("flash-on");
      }

      function triggerVisualFlash(periodMs) {
        visualIndicator.classList.add("flash-on");

        const flashDuration = Math.max(40, periodMs * 0.35);
        flashTimeoutId = setTimeout(() => {
          visualIndicator.classList.remove("flash-on");
        }, flashDuration);
      }

      function updateVisualFlashes() {
        stopVisualFlashes();

        if (!isPlaying) {
          return;
        }

        const beat = parseFloat(beatSlider.value);
        if (!beat || beat <= 0) return;

        const periodMs = 1000 / beat;
        triggerVisualFlash(periodMs);
        flashIntervalId = setInterval(() => triggerVisualFlash(periodMs), periodMs);
      }

      // Function to start the audio
      async function startTone() {
        if (isPlaying) return;

        try {
          await Tone.start();
          setupTone();
          createWaveformSources();

          setFrequencies();

          // Start the oscillators after setting the initial frequencies
          if (isIsochronicWaveform(waveformSelect.value)) {
            oscL.start();
            isoLfo.start();
          } else if (isNoiseWaveform(waveformSelect.value)) {
            oscL.start();
          } else {
            oscL.start();
            oscR.start();
          }
          isPlaying = true;

          updateToneButton();
          updateVisualFlashes();
        } catch (error) {
          console.error("Error starting Tone.js:", error);
          statusElement.textContent = "Error starting audio. Check console.";
        }
      }

      // Function to stop the audio
      function stopTone() {
        if (!isPlaying) return;

        disposeSources();

        // Disconnect to clean up resources
        if (pannerL) pannerL.dispose();
        if (pannerR) pannerR.dispose();

        pannerL = null;
        pannerR = null;

        isPlaying = false;
        updateToneButton();
        updateStatus("stopped"); // Update status on stop
        stopVisualFlashes();
      }

      // --- Event Listeners ---
      toggleToneButton.addEventListener("click", () => {
        if (isPlaying) {
          stopTone();
        } else {
          startTone();
        }
      });
      // Listener for Carrier Slider
      carrierSlider.addEventListener("input", () => {
        updateCarrierLabels();
        if (isPlaying) {
          setFrequencies(); // Update tone in real-time if playing
        }
        updateStatus(isPlaying ? "playing" : "stopped"); // Update status text
      });

      // Listener for Beat Slider
      beatSlider.addEventListener("input", () => {
        updateBeatLabels();
        if (isPlaying) {
          setFrequencies();
          updateVisualFlashes();
        }
        updateStatus(isPlaying ? "playing" : "stopped");
      });

      waveformSelect.addEventListener("change", () => {
        if (isPlaying) {
          disposeSources();
          setupTone();
          createWaveformSources();
          setFrequencies();

          if (isIsochronicWaveform(waveformSelect.value)) {
            oscL.start();
            isoLfo.start();
          } else if (isNoiseWaveform(waveformSelect.value)) {
            oscL.start();
          } else {
            oscL.start();
            oscR.start();
          }
        }
        updateStatus(isPlaying ? "playing" : "stopped");
        updateToneButton();
        updateVisualFlashes();
      });

      // Listener for Channel Preference Toggle
      channelToggleButton.addEventListener("click", () => {
        channelPreference = channelPreference === "left" ? "right" : "left";
        updateChannelToggle();
        if (isPlaying) {
          setFrequencies(); // Update tone in real-time if playing
        }
        updateStatus(isPlaying ? "playing" : "stopped"); // Update status text
      });

      // Initial status update on load
      window.addEventListener("load", () => {
        updateBeatLabels();
        updateCarrierLabels();
        updateStatus("stopped");
        updateToneButton();
        updateChannelToggle();
      });
    </script>
  </body>
</html>
